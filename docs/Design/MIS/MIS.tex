\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

%\externaldocument{../../SRS/SRS} %CHANGE BACK
\externaldocument{../SRS}
\input{../../Comments} % CHANGE BACK
\input{../../Common} % CHANGE BACK

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
18/1/2023 & 1.0 & Finished First Version\\
1/4/2023 & 2.0 & Finished Second Version\\
5/4/2023 & 2.0 & Addressed GitHub issues\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation on \href{https://github.com/brandonduong/Farming-Matters/blob/main/docs/SRS/SRS.pdf}{github}.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document outlines the system design of Farming Matters. The project aims to conduct survey research through an interactive and engaging activity. This will further help understand genuine decisions from the users to help with the research of understanding risk-making decisions. 

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be 
found on \href{https://github.com/brandonduong/Farming-Matters}{github}.

\section{Notation}
The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
string & String & a sequence of characters\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & $\mathbb{B}$ & any true or false value\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[H]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & - \\
\midrule

\multirow{10}{0.3\textwidth}{Behaviour-Hiding Module} & GameController\\
& AvatarMenu  \quad -- \textbf{done}\\
& Shop \quad -- \textbf{done}\\ 
& Inventory \quad -- \textbf{done}\\ 
& FarmGrid\\
& GameSettings \quad -- \textbf{done}\\
& CreateAccount\\
& Login\\
& SeasonalEvents\\
& GenerateStatistic\\
\midrule

\multirow{18}{0.3\textwidth}{Software-Hiding Module} & Avatar\\
& Consultant\\
& OtherAvatars\\
& FarmTile\\
& Seed\\
& Item \quad -- \textbf{done}\\ 
& DatabaseOperations \quad -- \textbf{done}\\ 
& ServerFirebase\\
& ClientFirebase\\
& AuthState\\
& Socket\\
& RedisClient\\
& Server\\ 
& MusicPlayer \quad -- \textbf{done}\\
& User \\
& AuthError \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage

% ----------------- MIS of GenerateStatistic
\section{MIS of GenerateStatistic} 


\subsection{Module}
Generate Statistic

\subsection{Uses}
GameController


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{6.5cm} p{4cm} p{3cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
generateConsultantStatement & $\mathbb{Z}, \text{GameController}$ & String & \\
\hline
generateGeneralStatement &  & String & \\
\hline
getEventHappening &  & $\mathbb{B}$ & \\
\hline
getEventType &  & String & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{pEventHappening}: \text{$\mathbb{Z}$}$\\
$\text{isEventHappening}: \text{$\mathbb{B}$}$\\
$\text{typeOfEvent}: \text{String}$\\

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}


\noindent generateConsultantStatement(decisionType, game):
\begin{itemize} 
\item output: $out := (\text{decisionType} = \text{PROBABLISTIC\_ID} \hspace{0.2cm} \land \hspace{0.2cm}  (\text{P\_SEASONAL\_LOW} \le  \newline randomProbability() \le  \text{P\_SEASONAL\_HIGH})\Rightarrow \newline generateSeasonalEventStatements(generateProbablisticValue(), \text{game}) \hspace{0.2cm} | \newline \text{decisionType} = \text{PROBABLISTIC\_ID} \hspace{0.2cm} \land \hspace{0.2cm} (\text{P\_MARKET\_LOW}\le randomProbability() \le   \text{P\_MARKET\_HIGH}) \Rightarrow  generateMarketStatements(generateDeterministicValue(), \text{game})  \hspace{0.2cm} | \newline \text{decisionType} =  \text{DETERMINISTIC\_ID} \hspace{0.2cm} \land \hspace{0.2cm} (\text{P\_SEASONAL\_LOW} \le randomProbability() \le   \text{P\_SEASONAL\_HIGH}) \Rightarrow  generateSeasonalEventStatements(generateProbablisticValue(), \newline \text{game}) \hspace{0.2cm} | \hspace{0.2cm} \text{decisionType} = \text{DETERMINISTIC\_ID} \hspace{0.2cm} \land \hspace{0.2cm}  (\text{P\_MARKET\_LOW} \le randomProbability() \le   \text{P\_MARKET\_HIGH}) \Rightarrow  generateMarketStatements(generateDeterministicValue(), \text{game})
)$
\item exception: none
\end{itemize}


\noindent generateGeneralStatement():
\begin{itemize}
\item output: $out := $ generateOtherStatement()
\item exception: none
\end{itemize}


\noindent getEventHappening():
\begin{itemize}
\item output: $out := \text{pEventHappening}$
\item exception: none
\end{itemize}


\noindent getEventType():
\begin{itemize}
\item output: $out := \text{typeOfEvent}$
\item exception: none
\end{itemize}



\subsubsection{Local Functions}
randomProbability: $ \mathbb{R}$  \\
This function produces a random real number between 0 and 1 \\

\noindent generateSeasonalEventStatements: $String \times GameController$ $\rightarrow $ seq of String  \\
generateSeasonalEventStatements(generatedDecisionTypeValue, game) $\equiv$ Based on the current season, generate a seasonal event statement related to the next season. Choose a random event that can occur in the next season along with a probability stating of it occurring or not.  \\

\noindent generateMarketStatements: $String \times GameController $ $\rightarrow $ seq of String  \\
generateMarketStatements(generatedDecisionTypeValue, game) $\equiv$ Based on the current season, generate a market statement related to the next season. Choose a random item along with a probability stating whether the price will either increase or decrease and another probability of it occurring or not.  \\

\noindent generateConsultantStatement: $\mathbb{Z}$ $\times$ GameController  $\rightarrow$ String\\
generateConsultantStatement(decisionType, game) $\equiv (\text{decisionType} = 
\text{PROBABLISTIC\_ID} \Rightarrow  relatedStatements(generateProbablisticValue(), \text{game}) | \newline \text{decisionType} = \text{DETERMINISTIC\_ID} \Rightarrow  relatedStatements(generateDeterministicValue(), \text{game}) )$   \\

\noindent realToString: $\mathbb{R}$  $\rightarrow$ String\\
realToString(realValue) $\equiv$ Given a real value, convert this to a string.  \\

\noindent booleanToString: $\mathbb{B}$  $\rightarrow$ String\\
booleanToString(booleanValue) $\equiv$ Given a boolean value, convert this to a string.  \\

\noindent generateProbablisticValue: void  $\rightarrow$ String\\
generateProbablisticValue() $\equiv realToString(\text{i} : \mathbb{R} | 0\le \text{i} \le 1) $  \\   
Generating a random real number between 0 and 1.\\

\noindent generateDeterministicValue: void  $\rightarrow$ String\\
generateDeterministicValue() $\equiv booleanToString(\text{i} : \mathbb{B} | \text{i}\equiv true \lor \text{i}\equiv false)$ \\
Generating a random boolean (true and false) value. \\

\noindent randomIndex: $\mathbb{Z}$ $\rightarrow \mathbb{R}$  \\
randomIndex(arrayLength) $\equiv i : \mathbb{R} | 0 \le i \le |arrayLength| - 1 $ \\
This function produces a random number between 0 and the length of the given array - 1. \\

\noindent generateOtherStatement: String\\
generateOtherStatement() $\equiv \newline \text{DEFAULT\_STATEMENTS}[randomIndex(\text{DEFAULT\_STATEMENTS)}]$  \\
This function will randomly select a default statement from a seq of default statements that are associated with General Avatar Statements.


\subsubsection{Local Constants}
SEASONS: seq of String\\
SEASONS = [``Fall", ``Winter", ``Spring", ``Summer"]\\

\noindent PROBABILISTIC\_ID: $\mathbb{Z}$\\
PROBABILISTIC\_ID = 0\\

\noindent DETERMINISTIC\_ID: $\mathbb{Z}$\\
DETERMINISTIC\_ID = 1\\


\noindent P\_SEASONAL\_LOW:  $\mathbb{R}$\\
P\_SEASONAL\_LOW = 0\\

\noindent P\_SEASONAL\_HIGH:  $\mathbb{R}$\\
P\_SEASONAL\_HIGH = 0.2\\

\noindent P\_MARKET\_LOW:  $\mathbb{R}$\\
P\_SEASONAL\_LOW = 0.2\\

\noindent P\_MARKET\_HIGH:  $\mathbb{R}$\\
P\_SEASONAL\_HIGH = 1\\

\noindent OTHER\_AVATAR\_STATEMENTS: seq of String



\newpage

% ----------------- MIS of Avatar
\section{MIS of Avatar} 


\subsection{Module}
Avatar

\subsection{Uses}
AvatarMenu


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
newAvatar & $\mathbb{Z}$,$\mathbb{Z}$, String, String, String, String & Avatar & \\
\hline
getID &  & $\mathbb{Z}$ & \\
\hline
getType &  & $\mathbb{Z}$ & \\
\hline
getName &  & String & \\
\hline
getRole &  & String & \\
\hline
getDescription &  & String & \\
\hline
getStatement &  & String & \\
\hline
setStatement &  String &  & \\
\hline
renderDialog &   & String & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{id}: \text{$\mathbb{Z}$}$\\
$\text{type}: \text{$\mathbb{Z}$}$\\
$\text{name}: \text{String}$\\
$\text{role}: \text{String}$\\
$\text{description}: \text{String}$\\
$\text{statement}: \text{String}$\\

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent new Avatar($\text{avatarID}, \text{avatarType}, \text{avatarName}, \text{avatarRole}, \text{avatarDescription}, \text{avatarStatement}$):
\begin{itemize}
\item transition: $\text{id}, \text{type}, \text{name}, \text{role}, \text{description}, \text{statement}:= \text{avatarID}, \text{avatarType}, \newline \text{avatarName}, \text{avatarRole},\text{avatarDescription}, \text{avatarStatement}$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}


\noindent getId():
\begin{itemize}
\item output: $out := \text{id}$
\item exception: none
\end{itemize}


\noindent getType():
\begin{itemize}
\item output: $out := \text{type}$
\item exception: none
\end{itemize}


\noindent getName():
\begin{itemize}
\item output: $out := \text{name}$
\item exception: none
\end{itemize}


\noindent getRole():
\begin{itemize}
\item output: $out := \text{role}$
\item exception: none
\end{itemize}

\noindent getDescription():
\begin{itemize}
\item output: $out := \text{description}$
\item exception: none
\end{itemize}

\noindent getStatement():
\begin{itemize}
\item output: $out := \text{statement}$
\item exception: none
\end{itemize}

\noindent setStatement(newStatement):
\begin{itemize}
\item transition: $\text{statement} := \text{newStatement}$
\item exception: none
\end{itemize}

\noindent renderDialog():
\begin{itemize}
\item output: $out := $ formats the styling of presenting a dialog to display all information about an avatar such as presenting the avatar's name, role, description and dialog statement.  
\item exception: none
\end{itemize}


\newpage

% ----------------- MIS of AvatarMenu
\section{MIS of AvatarMenu} 


\subsection{Module}
AvatarMenu

\subsection{Uses}
GameController, Avatar


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.5cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
newAvatarMenu & $\mathbb{Z}$ & AvatarMenu & \\
\hline
getSelectedAvatar &  & $\mathbb{Z}$ & \\
\hline
getDecisionType &  & $\mathbb{Z}$ & \\
\hline
getIsOpened &  & $\mathbb{B}$ & \\
\hline
onAvatarSelect &  $\mathbb{Z}$ &  & \\
\hline
onExitClick &   &  & \\
\hline
renderAvatarMenu &  & String & \\
\hline
generateAvatars &  &  & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{selectedAvatar}: \text{$\mathbb{Z}$}$\\
$\text{decisionType}: \text{$\mathbb{Z}$}$\\
$\text{isOpened}: \text{$\mathbb{B}$}$\\
$\text{avatars}: \text{seq of Avatar}$\\
\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent new AvatarMenu(userDecisionType):
\begin{itemize}
\item transition: $\text{selectedAvatar}, \text{decisionType}, \text{isOpened}:= \text{DEFAULT\_AVATAR}, \newline \text{userDecisionType}, \text{DEFAULT\_OPEN\_STATE}$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}


\noindent getSelectedAvatar():
\begin{itemize}
\item out: $out := \text{selectedAvatar}$
\item exception: none
\end{itemize}

\noindent getDecisionType():
\begin{itemize}
\item out: $out := \text{decisionType}$
\item exception: none
\end{itemize}

\noindent getIsOpened():
\begin{itemize}
\item out: $out := \text{isOpened}$
\item exception: none
\end{itemize}


\noindent onAvatarSelect(userSelectedAvatar):
\begin{itemize}
\item transition: $\text{isOpened}, \text{selectedAvatar} := true, (\text{a}: Avatar | \text{a} \in \text{avatars}: (a.getId() = \text{userSelectedAvatar})) $
\item exception: none
\end{itemize}

\noindent onExitClick():
\begin{itemize}
\item transition: $\text{isOpened}, \text{selectedAvatar} := \text{DEFAULT\_OPEN\_STATE}, \text{DEFAULT\_AVATAR}$
\item exception: none
\end{itemize}

Upon requesting to exit out of the Avatar Menu, reset $\text{isOpened}$ and $\text{selectedAvatar}$ to their default state.\\ 

\noindent generateAvatars():
\begin{itemize}
\item transition: $ \text{avatars} := (\text{index} : \mathbb{Z} | 0 \le \text{index} \le |\text{AVATARS\_ID}| - 1: \newline \text{avatars} || \{Avatar(\text{AVATARS\_ID[i]}, \text{AVATARS\_TYPE[i]}, \newline \text{AVATARS\_NAME[i]},  \text{AVATARS\_ROLE[i]}, \text{AVATARS\_DESCRIPTION[i]}, \newline \text{EMPTY\_STRING})\}  )$
\item exception: none
\end{itemize}
Generate a sequence of Avatar and concatenate to the state variable $avatars$.\\

\noindent renderAvatarMenu():
\begin{itemize}
\item out: formats the styling of presenting a menu with a list of in-game avatars to interact with.
\item exception: none
\end{itemize}

\subsubsection{Local Constants}
EMPTY\_STRING: String\\
DEFAULT\_AVATAR: $\mathbb{Z}$\\
DEFAULT\_OPEN\_STATE: $\mathbb{B}$\\
AVATARS\_ID: seq of $\mathbb{Z}$\\
AVATARS\_TYPE: seq of $\mathbb{Z}$\\
AVATARS\_NAME: seq of  String\\
AVATARS\_ROLE: seq of String\\
AVATARS\_DESCRIPTION: seq of String\\

\newpage


% ----------------- MIS of Consultant
\section{MIS of Consultant} 


\subsection{Module}
Consultant

\subsection{Uses}
GameController, GenerateStatistic


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
newConsultant & $\mathbb{Z}$ & Consultant & \\
\hline

purchaseConsultant &  & $\mathbb{B}$ & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{decisionType}: \text{$\mathbb{Z}$}$\\
$\text{statement}: \text{string}$\\
\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent new Consultant(userDecisionType):
\begin{itemize}
\item transition: $\text{decisionType, statement}:= \text{userDecisionType}$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}

\noindent purchaseConsultant():
\begin{itemize}
\item transition: $\text{statement}:= (canPurchaseConsultant(\text{game.money}) \Rightarrow \newline GenerateStatistics.genereateConsultantStatement(\text{decisionType, game}))$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}


Upon requesting to exit out of the Avatar Menu, reset $isOpened$ and $selectedAvatar$ to their default state 

\subsubsection{Local Functions}
randomIndex: $\mathbb{Z}$ $\rightarrow \mathbb{R}$  \\
randomIndex(arrayLength) $\equiv \text{i} : \mathbb{R} | 0 \le \text{i} \le |\text{arrayLength}| - 1 $ \\
This function produces a random number between 0 and the length of the given array - 1. \\

\noindent canPurchaseConsultant: $\mathbb{R}$ $\rightarrow \mathbb{B}$  \\
canPurchaseConsultant(currentMoney) $\equiv$ $(\text{currentMoney} < \text{DEFAULT\_PURCHASE\_PRICE} \Rightarrow false | \text{currentMoney} >= \text{DEFAULT\_PURCHASE\_PRICE} \Rightarrow true) $  \\
This function checks to see if the consultant's advice can be purchased given the money they have.

\subsubsection{Local Constants}

\noindent DEFAULT\_PURCHASE\_PRICE: $\mathbb{R}$\\
DEFAULT\_PURCHASE\_PRICE = 150.00


\newpage

% ----------------- MIS of OtherAvatar
\section{MIS of OtherAvatar} 


\subsection{Module}
OtherAvatar

\subsection{Uses}
Avatar


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
newOtherAvatar &  & OtherAvatar & \\
\hline

\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{statement}: \text{String}$\\
\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent new OtherAvatar():
\begin{itemize}
\item transition: $\text{statement}:= GenereateStatistcs.genereateGeneralStatement()$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}


% ----------------- MIS of SeasonalEvents
\section{MIS of SeasonalEvents} 


\subsection{Module}
Seasonal Events

\subsection{Uses}
GameController, FarmGrid, FarmTile, Inventory


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
renderSeasonTransition & String & String & \\
\hline

\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None
\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent renderSeasonTransition(season):
\begin{itemize}
\item transition: $\text{game} := $ all crops that are currently planted on the FarmGrid are removed and any crop that is insured is added to the Inventory
\item output: $out := $  formats the styling of displaying a seasonal event that occurs. This simulates the transition between seasons changing. There is a prompt description that displays an event statement that corresponds to that specific event in a given season. There is also a delay of SEASON\_TRANSITION\_DELAY seconds the season transition prompt cannot be exited until the SEASON\_TRANSITION\_DELAY time has been completed.

\item exception: none
\end{itemize}

\subsubsection{Local Constants}
SEASON\_TRANSITION\_DELAY: $\mathbb{Z}$\\
SEASON\_TRANSITION\_DELAY = 5



\newpage

\section{MIS of Item} 


\subsection{Module}
Item

\subsection{Uses}
None


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
newItem & String,$\mathbb{R}$,String & Item & \\
\hline
getName &  & String & \\
\hline
getFloorPrice &  & $\mathbb{R}$ & \\
\hline
getType &  & String & \\
\hline 
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{name}: \text{String}$\\
$\text{floorPrice}: \text{$\mathbb{R}$}$\\
$\text{type}: \text{String}$

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent new Item($\text{itemName}, \text{itemFloorPrice}, \text{itemType}$):
\begin{itemize}
\item transition: $\text{name}, \text{floorPrice}, \text{type}:= \text{itemName}, \text{itemFloorPrice}, \text{itemType},$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}


\noindent getName():
\begin{itemize}
\item output: $out := \text{name}$
\item exception: none
\end{itemize}

\noindent getFloorPrice():
\begin{itemize}
\item output: $out := \text{price}$
\item exception: none
\end{itemize}

\noindent getType():
\begin{itemize}
\item output: $out := \text{type}$
\item exception: none
\end{itemize}




\newpage

\section{MIS of Inventory} 


\subsection{Module}
Inventory

\subsection{Uses}
Item


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
newInventory & & Inventory \\
\hline
getItems &  & set of Item & \\
\hline
addItem & Item &  & \\
\hline
removeItem & Item & & Illegal Argument Exception\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{inventory}: \text{Seq of Item}$\\

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
An inventory will be created only at the beginning of the game or if the user wishes to delete their data and restart.

\subsubsection{Access Routine Semantics}

\noindent new Inventory():
\begin{itemize}
\item transition: $\text{inventory} := $ []
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}
This constructor will create an empty sequence as the user will start with no items when the game begins.

\noindent getItems():
\begin{itemize}
\item output: $out := \{ \text{i}: \text{Item} | \text{i} \in \text{inventory} : \text{i} \}$
\item exception: none
\end{itemize}

\noindent addItem(item):
\begin{itemize}
\item transition: $inventory := \text{inventory} \cup \{\text{item}\}$ 
\item exception: none
\end{itemize}

\medskip
\noindent removeItem(item):
\begin{itemize}
\item transition: $inventory := \text{inventory} $ - $ \{\text{item}\}$ 
\item exception: $exc :=  (\text{item} \notin \text{inventory}) \Rightarrow \text{IllegalArgumentException}$  
\end{itemize}


\newpage

\section{MIS of Shop} 


\subsection{Module}
Shop

\subsection{Uses}
Items, Inventory 


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{3cm} p{2cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
buyItems & Item,$\mathbb{Z}$,$\mathbb{R}$  &  & IllegalArgumentException \\
\hline
sellItems &  Item,$\mathbb{Z}$,$\mathbb{R}$ &  & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{inventory}: \text{set of Item}$\\
$\text{shopItems}: \text{set of Item}$\\
$\text{cropItems}: \text{set of Item}$\\
$\text{balance}: \mathbb{R}$\\
\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent buyItems(item,amount,floorPrice):
\begin{itemize}
\item transition: \\
$\text{balance} := (\text{balance} - \text{amount} \times (\text{item.price + floorPrice})) \hspace{0.2cm} where \hspace{0.2cm} (\text{item} \in \text{shopItems})\\ 
\text{inventory} := (\forall \text{x}: \mathbb{Z} | 0 \le x \le \text{amount}: \text{inventory}.addItem(\text{item}))$\\
\item exception: $exc := (\text{balance} < \text{amount} \times (\text{item.price + floorPrice}))  \Rightarrow
  \text{IllegalArgumentException}$\\
  Purchasing insurance on an item will mean the farmer is guaranteed to sell the item at a certain price(floorPrice). Since crop prices fluctuate, the price of the item they wish to sell may be lower than the buy price. This is meant to ensure the buyer does not lose any money when selling. 
\end{itemize}

\noindent sellItems(item,amount,floorPrice) :
\begin{itemize}
\item transition: \\
$\text{balance} := (\text{balance} + \text{amount} \times \text{item.price}) \hspace{0.2cm} where \hspace{0.2cm} (\text{item} \in \text{cropItems}) \land (\text{item} \in \text{inventory}) \land (\text{item.floorPrice} = \text{floorPrice})  \\
\text{inventory} := (\forall \text{x}: \mathbb{Z} | 0 \le x \le \text{amount}: \text{inventory}.removeItem(\text{item}))$\\
\item exception: $exc :=$ None
\end{itemize}

\medskip
\newpage
% Not sure if there should be exceptions if the db is unable to be connected with
\section{MIS of DatabaseOperations} 


\subsection{Module}
DatabaseOperations

\subsection{Uses}
AuthState, GameController

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
createConnection &   & $\mathbb{B}$ & \\
\hline
stopConnection &   & $\mathbb{B}$ & \\
\hline
createUserTable & $\mathbb{Z}$ &  &  \\
\hline
deleteUserTable & $\mathbb{Z}$ &  &  \\
\hline
logData & $\mathbb{Z}$, set of ActionDetails  &  & IllegalArgument
Exception\\
\hline
saveGame & $\mathbb{Z}$, set of MapGameStates &  & IllegalArgument Exception \\
\hline
loadGame & $\mathbb{Z}$ & set of MapGameStates & IllegalArguement
Exception \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\text{isConnected}: $\mathbb{B}$
\subsubsection{Environment Variables}
None
\subsubsection{Assumptions}
The database server is running allowing for connection with valid incoming requests.

\subsubsection{Access Routine Semantics}

\noindent createConnection():
\begin{itemize}
\item output: $out :=$ If the user is logged in and not connected to the database server, send a request to using CREDENTIALS for access. Return True if the request is successful, False otherwise. If the user is not logged in or there is already a connection to the database, return False.
\item transition: \text{isConnected} := True if request successful or there is already a connection, False otherwise
\item exception: none
\end{itemize}

\noindent stopConnection():
\begin{itemize}
\item output: $out := $ If the user is logged in and there is a connection to the database server, send a request to stop the connection. If the request is successful, return True and False otherwise. Return False, if the user is not logged in or there is no connection to the database.
\item transition: \text{isConnected} := False if request successful or there is already not a connection, True otherwise
\item exception: none
\end{itemize}

\noindent createUserTable(userId):
\begin{itemize}
\item output: $out := $ If the user is logged in, the database is connected, and there is not a table corresponding to the userId, create a table corresponding using the userId.
\item exception: None
\end{itemize}

\noindent deleteUserTable(userId):
\begin{itemize}
\item output: $out := $ If the user is logged in, the database is connected, and there is a table corresponding to the userId, delete the table corresponding using the userId.
\item exception: None
\end{itemize}

\noindent logData(userId, action):
\begin{itemize}
\item transition: If the user is logged in and the database is connected, add an entry in the database table corresponding to the userId.
\item exception: If there is not a table corresponding to the userId, raise IllegalArguementException.
\end{itemize}

\noindent saveGame(userId, gameStateData):
\begin{itemize}
\item transition: If the user is logged in and the database is connected, modify the entry in the game state table corresponding to the userId with the gameStateData.
\item exception: If there is not a table corresponding to the userId, raise IllegalArguementException.
\end{itemize}

\noindent loadGame(userId):
\begin{itemize}
\item output: $out := $ If the user is logged in and the database is connected, return the entry in the game state table corresponding to the userId.
\item exception: If there is not a table corresponding to the userId, raise IllegalArguementException.
\end{itemize}

\subsubsection{Local Constants}
CREDENTIALS: set of MapAuthInfo \#mapping authentication secret keys and values\\
\medskip
\newpage
\section{MIS of MusicPlayer}

\subsection{Module}

MusicPlayer

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
loadMusic & String &  & InvalidFile \\
\hline
startMusic & $\mathbb{R}$ &  & IllegalArguement \\
\hline
changeVolume & $\mathbb{R}$ &  & IllegalArguement \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\text{audioFile}: Audio\\
\text{isPlaying}: $\mathbb{B}$\\
\text{volume}: $\mathbb{R}$\\
\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent loadMusic(audioFileName):
\begin{itemize}
\item transition: \text{audioFile} := audioFileName
\item exception: If the given audio file name does not exist in the directory or the provided file name is of invalid type, raise invalidFile exception.
\end{itemize}

\noindent startMusic(volume):
\begin{itemize}
\item transition: \text{audioFile}, \text{volume}, \text{isPlaying} := If isPlaying is False, start playing the audio file in an infinite loop, otherwise continue playing the music, volume, True \\
\item exception: (volume $<$ 0 $\Rightarrow$ IllegalArguement)
\end{itemize}

\noindent changeVolume(volume):
\begin{itemize}
\item transition: \text{volume} := volume
\item exception: (volume $<$ 0 $\Rightarrow$ IllegalArguement)
\end{itemize}

\subsubsection{Local Functions}

None

\medskip
\newpage
\section{MIS of GameSettings} 


\subsection{Module}
GameSettings

\subsection{Uses}
DatabaseOperations, MusicPlayer


\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
setVolumeBackgroun-dMusic & $\mathbb{R}$  &  & IllegalArguement
Exception \\
\hline
setVolumeSoundEffects & $\mathbb{R}$  &  & IllegalArguement
Exception \\
\hline
withdrawFromStudy & String  &  & \\
\hline
withdrawFromGame & String &  & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
backgroundMusicVolume: $\mathbb{R}$
soundEffectsVolume: $\mathbb{R}$
\subsubsection{Environment Variables}
None
\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}

\noindent setVolumeBackgroundMusic(volume):
\begin{itemize}
\item transition: \text{backgroundMusicVolume} := volume
\item exception: (volume $<$ 0 $\Rightarrow$ IllegalArguementException)
\end{itemize}

\noindent setVolumeSoundEffects(volume):
\begin{itemize}
\item transition: $\text{currentVolume} := \text{newVolume}$ 
\item exception: (volume $<$ 0 $\Rightarrow$ IllegalArguementException)
\end{itemize}

\noindent withdrawFromStudy(userId):
\begin{itemize}
\item output: $out := $ Deletes the user table using DatabaseOperations.deleteUserTable and also removes the entry corresponding to the userId in the game state table. The user information is also removed from Firebase.
\item exception: None
\end{itemize}

\noindent withdrawFromGame(userId):
\begin{itemize}
\item output: $out := $ The user information is removed from Firebase.
\item exception: None
\end{itemize}

\medskip
\newpage
% ***************************** MIS of AuthState *****************************
\section{MIS of AuthState} \label{AuthState} 

\subsection{Module}

AuthState

\subsection{Uses}

User, AuthError, Socket, ClientFirebase, DatabaseOperations

\subsection{Syntax}

\subsubsection{Exported Constants}
None
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
getUser &  & $\{$User$\}$ $\cup$ $\{$null$\}$ &  \\ \hline
getUserId &  & $\{$String$\}$ $\cup$ $\{$null$\}$ &  \\ \hline
getIsLoggedIn &  & $\mathbb{B}$ &  \\ \hline
getIsActiveSession &  & $\mathbb{B}$ &  \\ \hline
getIsDenied &  & $\mathbb{B}$ &  \\ \hline
getAuthError &  & AuthError &  \\ \hline
signIn & String, String &  &  \\ \hline
signOut & &  &  \\ \hline
createAccount & String, String, String &  &  \\ \hline
\end{tabular}
\end{center}
Note: There are no exceptions present because instead of throwing exceptions, auth errors in all access programs are handled internally using the authError state variable.
\subsection{Semantics}

\subsubsection{State Variables}

user: User  \\
isLoggedIn: $\mathbb{B}$ \\
isActiveSession: $\mathbb{B}$ \\
isDenied: $\mathbb{B}$ \\
authError: AuthError \\
socket: Socket \\

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

This module is the 'source of truth' for anything auth-related. This is an assumption guaranteed by this module.

\subsubsection{Access Routine Semantics}

\noindent getUser():
\begin{itemize}
\item output: $out := ((\text{isLoggedIn} \land \lnot \text{isDenied}) \Rightarrow \text{user}) \ | \ (\text{True} \Rightarrow \text{null})$
\end{itemize}

\noindent getUserId():
\begin{itemize}
\item output: $out := ((\text{isLoggedIn} \land \lnot \text{isDenied}) \Rightarrow \text{user.uid}) \ | \ (\text{True} \Rightarrow \text{null})$
\end{itemize}

\noindent getIsLoggedIn():
\begin{itemize}
\item output: $out := \text{isLoggedIn}$
\end{itemize}

\noindent getIsActiveSession():
\begin{itemize}
\item output: $out := \text{isActiveSession}$
\end{itemize}

\noindent getIsDenied():
\begin{itemize}
\item output: $out := \text{isDenied}$
\end{itemize}

\noindent getAuthError():
\begin{itemize}
\item output: $out := \text{authError}$
\end{itemize}

\noindent signIn(email, password):
\begin{itemize}
\item transition: \\
Note that $\text{userCredential}$ is a temporary variable in this method used to store the results of calling the Firebase API. It is not a state variable. \\ \\
$\text{userCredential} :=  ClientFirebase.signInWithEmailAndPassword(\text{email, password})$ \\

$\text{user} := (\text{userCrediential.user} \neq \text{null} \Rightarrow \text{userCredential.user}) \ | \ (\text{userCrediential.user} = \text{null} \Rightarrow \text{null})$ \\

$\text{isLoggedIn} := (\text{userCrediential.user} \neq \text{null})$ \\

$\text{isActiveSession} := \\ (\text{userCrediential.user} \neq \text{null}) \\ \Rightarrow \text{socket}.checkIsOnlySession(\text{userCredential.user.uid, userCrediential.user.accessToken}) \\
| \ (\text{userCrediential.user} = \text{null}) \Rightarrow \text {false}$ \\

$\text{isDenied} := (\text{userCrediential.error} \neq \text{null})$ \\

$\text{authError} := \text{isDenied} \Rightarrow \text{userCredential.error} \ | \ \lnot \text{isDenied} \Rightarrow \text{null} $

\end{itemize}

\noindent signOut():
\begin{itemize}
\item transition: \\
$\text{user} := \text{null}$ 

$\text{isLoggedIn} := \text{false}$ 

$\text{isActiveSession} := \text{false}$

$\text{isDenied} := \text{false}$

$\text{authError} := \text{null}$

\item side effect: \\
Because the app needs to keep track of which users have a unique session active, the frontend needs to notify the server when a user signs out so their active status can be removed. \\ \\
$\text{socket}.userSignedOut(getUserId(), getUser().accessToken)$

\end{itemize}

\noindent createAccount(displayName, email, password):
\begin{itemize}
\item transition: \\ 
Note that $\text{userCredential}$ is a temporary variable in this method used to store the results of calling the Firebase API. It is not a state variable. \\ \\
$\text{userCredential} :=  ClientFirebase.createUserWithEmailAndPassword(\text{email, password})$ \\

$\text{user} := (\text{userCrediential.user} \neq \text{null} \Rightarrow \text{userCredential.user}) \ | \ (\text{userCrediential.user} = \text{null} \Rightarrow \text{null})$ \\

$\text{isLoggedIn} := (\text{userCrediential.user} \neq \text{null})$ \\

$\text{isActiveSession} := (\text{userCrediential.user} \neq \text{null})$ \\

$\text{isDenied} := (\text{userCrediential.error} \neq \text{null})$ \\

$\text{authError} := \text{isDenied} \Rightarrow \text{userCredential.error} \ | \ \lnot \text{isDenied} \Rightarrow \text{null} $

\item side effect: Calls the createUserTable method from the DatabaseOperations module on successful account creation. \\

$(\text{userCrediential.user} \neq \text{null}) \Rightarrow \\
DatabaseOperations.createUserTable(\text{userCredential.user.uid})$ \\
\\ Also notifies the socket that a new user is connected. \\ 
\\ $\text{socket}.checkIsOnlySession(\text{userCredential.user.uid, userCrediential.user.accessToken})$

\end{itemize}

  
\medskip
\newpage
% ***************************** MIS of Socket *****************************
\section{MIS of Socket} \label{Socket} 

\subsection{Module}

Socket (inherits Socket from \href{https://socket.io/docs/v4/client-socket-instance/}{socket-io}).\\ \\
The Socket module defines a few methods using the underlying communication infrastructure of the socket-io package. This is one of the modules used to communicate between client and server, the other being DatabaseOperations.

\subsection{Uses}

Server

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
checkIsOnlySession & String, String & $\mathbb{B}$ & InvalidUserIdException \\ \hline
userSignedOut & String, String & $\mathbb{B}$ & InvalidUserIdException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

$\text{isClientDisconnected}: \mathbb{B}$ \\
socket-io features a built-in \href{https://socket.io/docs/v4/client-socket-instance/#disconnect}{disconnect event} which fires when the client disconnects from the socket. This environment variable represents the event firing.  

\subsubsection{Assumptions}

The socket-io package behaves as expected and the disconnect event fires correctly whenever a client ends their connection with the socket. \\ \\
The server is always on and connected to the socket.

\subsubsection{Access Routine Semantics}

\noindent checkIsOnlySession(userId, token):
\begin{itemize}
\item output: $out := Server.userExists(\text{userId})$
\item side effect: \\
If there is no active user then the socket notifies the server that a new unique session is created. \\
$(Server.userExists(\text{userId}) = \text{false}) \Rightarrow Server.addUser(\text{userId, token})$ 

\item exception: $exception := isValidUUID(userId) \Rightarrow \text{InvalidUserIdException}$ 
\end{itemize}

\noindent userSignedOut(userId, token):
\begin{itemize}
\item side effect: \\
$Server.deleteUser(\text{userId, token})$ 

\item exception: $exception := isValidUUID(\text{userId}) \Rightarrow \text{InvalidUserIdException}$ 
\end{itemize}

The following access routine is called upon a client disconnecting (see \href{https://socket.io/docs/v4/client-socket-instance/#disconnect}{socket-io docs}). 
\noindent userDisconnected(userId, token):
\begin{itemize}
\item side effect: \\
$\text{isClientDisconnected} \Rightarrow Server.deleteUser(\text{userId, token})$ 

\item exception: $exception := isValidUUID(\text{userId}) \Rightarrow \text{InvalidUserIdException}$ 
\end{itemize}

\subsubsection{Local Functions}

isValidUUID: String $\rightarrow \mathbb{B}$  \\
isValidUUID(userId) $\equiv$ userId $\in$ $\{$[0-9a-fA-F]$\{$8$\}$\textbackslash b-[0-9a-fA-F]$\{$4$\}$\textbackslash b-[0-9a-fA-F]$\{$4$\}$\textbackslash b-[0-9a-fA-F]$\{$4$\}$\textbackslash b-[0-9a-fA-F]$\{$12$\}$$\}$ \\
This function makes sure that the format of the userId is a valid UUID (Universally Unique Identifier). The regular expression above represents the set of all allowable strings.  \\
  
\medskip
\newpage
% ***************************** MIS of ClientFirebase *****************************
\section{MIS of ClientFirebase} \label{ClientFirebase} 

\subsection{Module}

ClientFirebase inherits \href{https://firebase.google.com/docs/reference/js/auth}{firebase.auth} \\ \\
This module uses API credentials to give access to Firebase. For details of all syntax and semantics of exported constants and access programs, see the \href{https://firebase.google.com/docs/reference/js/auth}{firebase auth package documentation}.
\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

See the \href{https://firebase.google.com/docs/reference/js/auth}{firebase auth package documentation}.

\subsubsection{Exported Access Programs}

See the \href{https://firebase.google.com/docs/reference/js/auth}{firebase auth package documentation}.

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

The underlying Firebase instance is always working properly. Credentials are correct and never need to be updated.

\subsubsection{Access Routine Semantics}

\noindent new ClientFirebase():
\begin{itemize} 
\item output: $out := self$ 
\item exception: $exception := \text{InvalidCredentialException}$ if the FIREBASE\_API\_KEY is invalid.  
\end{itemize} 

\subsubsection{Local Constants}

FIREBASE\_API\_KEY: String \\
The API key to access the Firebase instance.
  
\medskip
\newpage
% ***************************** MIS of User *****************************
\section{MIS of User} \label{User} 

\subsection{Module}

\href{https://firebase.google.com/docs/reference/js/v8/firebase.User}{firebase.auth.User} \\ \\
This module is defined by Firebase. See the linked documentation for all exported constants and access routines.
  
\medskip
\newpage
% ***************************** MIS of AuthError *****************************
\section{MIS of AuthError} \label{AuthError} 

\subsection{AuthError}

\href{https://firebase.google.com/docs/reference/js/auth.autherror}{firebase.auth.AuthError} \\ \\
This module is defined by Firebase. See the linked documentation for all exported constants.
  
\medskip
\newpage
% ***************************** MIS of CreateAccount *****************************
\section{MIS of CreateAccount} \label{CreateAccount} 

\subsection{Module}

CreateAccount

\subsection{Uses}

AuthState

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
setDisplayName & String &  & InvalidDisplayNameException \\ \hline
setEmail & String &  & InvalidEmailException \\ \hline
setPassword & String &  & InvalidPasswordException \\ \hline
setConfirmPassword & String & \\ \hline
clickCreateAccount &  &  & IncorrectCredentialsException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
displayName: String \\ 
email: String \\ 
password: String  \\ 
confirmPassword: String  \\

\subsubsection{Environment Variables}

These environment variables capture input from the keyboard. They each correspond to their input section where a user may type. \\ \\
inputDisplayName: String \\ 
inputEmail: String \\ 
inputPassword: String  \\ 
inputConfirmPassword: String  \\ 

\subsubsection{Assumptions}
An important assumption for security is that all client-server requests will use HTTPS, allowing for a secure connection when dealing with sensitive data.
\\
\\ It is clear to the users which section to type in concerning the environment variables (eg. The section capturing keyboard input for displayName should be labelled with 'Display Name'). 

\subsubsection{Access Routine Semantics}

\noindent setDisplayName(inputDisplayName):
\begin{itemize}
\item transition: $\text{displayName} := \text{inputDisplayName}$
\item exception: \\$exception := isInvalidDisplayName(\text{inputDisplayName}) \Rightarrow \text{InvalidDisplayNameException}$
\end{itemize}

\noindent setEmail(inputEmail):
\begin{itemize}
\item transition: $\text{email} := \text{inputEmail}$
\item exception: $exception := isInvalidEmail(\text{inputEmail}) \Rightarrow \text{InvalidEmailException}$
\end{itemize}

\noindent setPassword(inputPassword):
\begin{itemize}
\item transition: $\text{email} := \text{inputEmail}$
\item exception: $exception := isInvalidEmail(\text{inputEmail}) \Rightarrow \text{InvalidEmailException}$
\end{itemize}

\noindent setConfirmPassword(inputConfirmPassword):
\begin{itemize}
\item transition: $\text{confirmPassword} := \text{inputConfirmPassword}$
\end{itemize}

\noindent clickCreateAccount():
\begin{itemize}
\item side effect: \\$(\text{password} = \text{confirmPassword}) \ \land \ (humanVerification() = \text{true}) \Rightarrow AuthState.createAccount(\text{displayName, email, password})$
\item exception: $exception := (AuthState.getAuthError() \neq \text{null} \ \lor \  \text{password} \neq \text{confirmPassword}) \\ \Rightarrow \text{IncorrectCredentialsException}$ 
\end{itemize}

\subsubsection{Local Functions}
isInvalidDisplayName: String $\rightarrow \mathbb{B}$  \\
isInvalidDisplayName(displayName) $\equiv$ displayName $\notin$ $\{$/(.*[[a-zA-Z0-9]])\{3\}/i$\}$ 
\\ \\
This function validates the displayName input. Valid display names are at least 3 characters long and only consist of alphanumeric characters. \\ 
\\ 
\\
isInvalidEmail: String $\rightarrow \mathbb{B}$  \\
isInvalidEmail(email) $\equiv$ email $\notin$ $\{$/([a-zA-Z0-9.!\#\%\&'*+/=?\^\_`\{|\}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*/$\}$ 
\\ \\
This function validates the email input. Valid emails contain only valid characters and contain an '@' in the middle. \\
\\
\\
isInvalidPassword: String $\rightarrow \mathbb{B}$  \\
isInvalidPassword(password) $\equiv$ password $\notin$ $\{$/\^.\{6,\}/$\}$ 
\\ \\
This function validates the password input. Valid passwords are at least 6 characters long.  
\\ \\
\\
humanVerification: $\mathbb{B}$\\
humanVerification() $\equiv$ This function validates if the individual creating an account is human by using a CAPTCHA system. This is to prevent individuals from using automation scripts to spam the server with several bot accounts.


\medskip
\newpage
% ***************************** MIS of Login *****************************
\section{MIS of Login} \label{Login} 

\subsection{Module}

Login

\subsection{Uses}

AuthState

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{1cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
setEmail & String &  & InvalidEmailException \\ \hline
setPassword & String &  & InvalidPasswordException \\ \hline
clickLogin &  &  & IncorrectCredentialsException, InvalidSessionException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
 email: String \\ 
password: String  \\ 

\subsubsection{Environment Variables}

These environment variables capture input from the keyboard. They each correspond to their input section where a user may type. \\ \\
inputEmail: String \\ 
inputPassword: String  \\ 

\subsubsection{Assumptions}
An important assumption for security is that all client-server requests will use HTTPS, allowing for a secure connection when dealing with sensitive data.
\\
\\ It is clear to the users which section to type in concerning the environment variables (eg. The section capturing keyboard input for the email should be labelled with 'Email'). 

\subsubsection{Access Routine Semantics}

\noindent setEmail(inputEmail):
\begin{itemize}
\item transition: $\text{email} := \text{inputEmail}$
\item exception: $exception := isInvalidEmail(\text{inputEmail}) \Rightarrow \text{InvalidEmailException}$
\end{itemize}

\noindent setPassword(inputPassword):
\begin{itemize}
\item transition: $\text{email} := \text{inputEmail}$
\item exception: $exception := isInvalidEmail(\text{inputEmail}) \Rightarrow \text{InvalidEmailException}$
\end{itemize}

\noindent clickLogin():
\begin{itemize}
\item side effect: \\$AuthState.signIn(\text{email, password})$
\item exception: $exception := \\(AuthState.getAuthError() \neq \text{null} \ \lor \ AuthState.getIsDenied() = \text{true}) \\ \Rightarrow \text{IncorrectCredentialsException}  \\
| \ (AuthState.getIsActiveSession() = \text{false}) \Rightarrow \text{InvalidSessionException}$ 
\end{itemize}

\subsubsection{Local Functions}
isInvalidEmail: String $\rightarrow \mathbb{B}$  \\
isInvalidEmail(email) $\equiv$ email $\notin$ $\{$/([a-zA-Z0-9.!\#\%\&'*+/=?\^\_`\{|\}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*/$\}$ 
\\ \\
This function validates the email input. Valid emails contain only valid characters and contain an '@' in the middle. \\ 
\\
\\
isInvalidPassword: String $\rightarrow \mathbb{B}$  \\
isInvalidPassword(password) $\equiv$ password $\notin$ $\{$/\^.\{6,\}/$\}$ 
\\ \\
This function validates the password input. Valid passwords are at least 6 characters long. 
\\ \\
  
\medskip
\newpage
% ***************************** MIS of ServerFirebase *****************************
\section{MIS of ServerFirebase} \label{ServerFirebase} 

\subsection{Module}

ServerFirebase inherits \href{https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth}{firebase-admin.auth} \\ \\
This module uses API credentials to give access to the server-side instance of Firebase, which can be used for privileged operations. For details of all syntax and semantics of exported constants and access programs, see the \href{https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth}{Firebase auth package documentation}. Note that the firebase-admin Auth class further inherits the \href{https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth.baseauth.md#baseauth_class}{BaseAuth} class. This should be referenced for exported access routines. 
\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

See the \href{https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth.baseauth.md#baseauth_class}{Firebase BaseAuth package documentation}. 

\subsubsection{Exported Access Programs}

See the \href{https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth.baseauth.md#baseauth_class}{Firebase BaseAuth package documentation}.

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

The underlying Firebase instance is always working properly. Credentials are correct and never need to be updated.

\subsubsection{Access Routine Semantics}

\noindent new ServerFirebase():
\begin{itemize} 
\item output: $out := self$ 
\item exception: $exception := \text{InvalidCredentialException}$ if the FIREBASE-ADMIN\_API\_KEY is invalid.  
\end{itemize} 

\subsubsection{Local Constants}

FIREBASE-ADMIN\_API\_KEY: String \\
The API key to access the firebase-admin instance.
  
\medskip
\newpage
% ***************************** MIS of RedisClient *****************************
\section{MIS of RedisClient} \label{RedisClient} 

\subsection{Module}

RedisClient inherits \href{https://luin.github.io/ioredis/classes/Redis.html}{ioredis.Redis} \\ \\
This module uses API credentials to give access to the Redis database hosted on the cloud (\href{https://app.redislabs.com/#/}{Redis Labs}) specifically. Redis is typically used as a key-value store but in this case, we will use it like a set (which is natively supported). 
\\
\\For details of all syntax and semantics of exported constants and access programs, see the \href{https://luin.github.io/ioredis/classes/Redis.html}{ioredis.Redis documentation}. 
\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

See the \href{https://luin.github.io/ioredis/classes/Redis.html}{ioredis.Redis documentation}. 

\subsubsection{Exported Access Programs}

See the \href{https://luin.github.io/ioredis/classes/Redis.html}{ioredis.Redis documentation}.

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

The underlying Redis instance is always working properly. Credentials are correct and never need to be updated.

\subsubsection{Access Routine Semantics}

\noindent new RedisClient():
\begin{itemize} 
\item output: $out := self$ 
\item exception: $exception := \text{InvalidCredentialException}$ if the REDIS\_API\_KEY is invalid.  
\end{itemize} 

\subsubsection{Local Constants}

REDIS\_API\_KEY: String \\
The API key to access the Redis instance.
  
\medskip
\newpage
% ***************************** MIS of Server *****************************
\section{MIS of Server} \label{Server} 

\subsection{Module}

Server

\subsection{Uses}

RedisClient, ServerFirebase

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{2cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
userExists & String & $\mathbb{B}$ & \\ \hline
addUser & String, String & & \\ \hline
deleteUser & String, String & & \\ \hline
checkToken & & $\mathbb{B}$ & InvalidTokenException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

redis: RedisClient

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

The hardware running the server is always functional while the application is being used.

\subsubsection{Access Routine Semantics}

\noindent userExists(userId):
\begin{itemize}
\item output: $out := redis.ismember(\text{userId}) = \text{true}$
\end{itemize}

\noindent addUser(userId, token):
\begin{itemize}
\item side effect: $checkToken(\text{token}) \Rightarrow redis.sadd(\text{userId})$
\end{itemize}

\noindent deleteUser(userId, token):
\begin{itemize}
\item output: $checkToken(\text{token}) \Rightarrow redis.srem(\text{userId})$
\end{itemize}

\noindent checkToken(token):
\begin{itemize}
\item output: $out := ServerFirebase.verifyIdToken(\text{token})$
\end{itemize}

\subsubsection{Local Functions}

None.
  
\medskip
\newpage

% ***************************** MIS of Seed *****************************
\section{MIS of Seed} \label{Seed} 

\subsection{Module inherits Item}

Seed

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
Seed & $String, \mathbb{N}, \mathbb{R}$ & - & - \\
\hline
getGrowthLength & - & $\mathbb{N}$ & - \\
\hline
getPlantableSeasons & - & set of String & - \\
\hline
getSellValueRanges & - & seq of $\mathbb{N}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{growthLength}: \text{$\mathbb{N}$}$\\
$\text{plantableSeasons}:$ set of \text{String}\\
$\text{sellValueRanges}:$ seq of \text{$\mathbb{N}$}\\

\subsubsection{Environment Variables}

None
\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent new Seed($\text{itemName}, \text{itemCount}, \text{itemPrice}, \text{growthLength}, \text{plantableSeasons}, \text{sellValueRanges}$):
\begin{itemize}
\item transition: $\text{name}, \text{count}, \text{price}, \text{type}, \text{growthLength}, \text{plantableSeasons}, \text{sellValueRanges}:= \text{itemName}, \text{itemCount}, \text{itemPrice}$, $\text{'Seed'} , \text{growthLength}, \text{plantableSeasons}, \text{sellValueRanges}$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}


\noindent getGrowthLength():
\begin{itemize}
\item output: $out := \text{growthLength}$
\item exception: none
\end{itemize}

\noindent getPlantableSeasons():
\begin{itemize}
\item output: $out := \text{plantableSeasons}$
\item exception: none
\end{itemize}

\noindent getSellValueRanges():
\begin{itemize}
\item output: $out := \text{sellValueRanges}$
\item exception: none
\end{itemize}

  
\medskip
\newpage

% ***************************** MIS of FarmTile *****************************
\section{MIS of FarmTile} \label{FarmTile} 

\subsection{Module}

FarmTile

\subsection{Uses}

Seed, Inventory, GameController

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
FarmTile & $\mathbb{Z}$, $\mathbb{Z}$ & FarmTile &  \\
\hline
plantSeed & Seed, $\mathbb{N}$ & - & AlreadyPlantedSeed, \\&&& NoSeed, \\&&& NotInSeason  \\
\hline
getPlantedSeed & - & Seed & NoPlantedSeed \\
\hline
getTurnPlanted & - & $\mathbb{N}$ & NoPlantedSeed \\
\hline
harvestCrop & - & - & InvalidHarvest, \\&&&NoPlantedSeed \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{x}:$ \text{$\mathbb{Z}$}\\
$\text{y}:$ \text{$\mathbb{Z}$}\\
$\text{plantedSeed}:$ \text{Seed}\\
$\text{turnPlanted}:$ \text{$\mathbb{N}$}\\

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent new FarmTile(x, y):
\begin{itemize}
\item transition: $\text{x, y := x, y}$
\item output: $out := \text{self}$
\item exception: none
\end{itemize}

\noindent plantSeed(seed, turn):
\begin{itemize}
\item transition: $\text{plantedSeed, turnPlanted := seed, turn}$
\item exception: $exc := \text{plantedSeed} \neq \text{null} \implies \text{AlreadyPlantedSeed}$ $|$\\ $  \neg \exists (\text{i} : \text{Item} | \text{i} \in \text{Inventory}.getItems() : \text{i}.getName() = \text{seed}.getName()) \implies \text{NoSeed}$ $|$\\ $\text{GameController}.getSeason() \notin \text{seed}.getPlantableSeasons() \implies \text{NotInSeason}$
\end{itemize}

\noindent getPlantedSeed():
\begin{itemize}
\item output: $out := \text{plantedSeed}$
\item exception: $exc := (\text{plantedSeed = null}) \implies \text{NoPlantedSeed}$
\end{itemize}

\noindent getTurnPlanted():
\begin{itemize}
\item output: $out := \text{turnPlanted}$
\item exception: $exc := (\text{plantedSeed = null}) \implies \text{NoPlantedSeed}$
\end{itemize}

\noindent harvestPlant():
\begin{itemize}
\item transition: $\text{plantedSeed, turnPlanted} := \text{null, null}$
\item exception: $exc := \text{plantedSeed = null} \implies \text{NoPlantedSeed}$ $|$ $\neg(\text{GameController.turn} - \text{turnPlanted} \ge \text{plantedSeed}.getGrowthLength()) \implies \text{InvalidHarvest}$
\end{itemize}

  
\medskip
\newpage

% ***************************** MIS of FarmGrid *****************************
\section{MIS of FarmGrid} \label{FarmGrid} 

\subsection{Module}

FarmGrid

\subsection{Uses}

FarmTile

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
FarmGrid & set of FarmTile & FarmGrid & - \\
\hline
getTiles & & set of FarmTile & - \\
\hline
addTile & FarmTile & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

$\text{tiles} :$ set of FarmTile

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent new FarmGrid(tiles):
\begin{itemize}
\item transition: $\text{tiles} := \text{tiles}$
\item output: $out := \text{self}$
\item exception: none
\end{itemize}

\noindent getTiles():
\begin{itemize}
\item output: $out := \text{tiles}$
\item exception: none
\end{itemize}

\noindent addTile(tile):
\begin{itemize}
\item transition: $\text{tiles} := \text{tiles} \cup \{\text{tile}\}$
\item exception: none
\end{itemize}

  
\medskip
\newpage

% ***************************** MIS of GameController *****************************
\section{MIS of GameController} \label{ServerAuth} 

\subsection{Module}

GameController

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

SEASONS = ['Winter', 'Spring', 'Summer', 'Fall']

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
GameController & $\mathbb{N}$, $\mathbb{N}$ & GameController & - \\
\hline
getTurn & - & $\mathbb{N}$ & - \\
\hline
setTurn & $\mathbb{N}$ &-& - \\
\hline
getMoney & - & $\mathbb{N}$ & - \\
\hline
setMoney & $\mathbb{N}$ &-& - \\
\hline
getSeason & - & String & - \\
\hline
getDecisionType & - &  $\mathbb{Z}$ & - \\
\hline
getMarketItems & - & set of Item & - \\
\hline
getAccessToConsultant & - & $\mathbb{B}$ & - \\
\hline
setAccessToConsultant & $\mathbb{B}$ & - & - \\
\hline
getEventHappening & - & $\mathbb{B}$ & - \\
\hline
setEventHappening & $\mathbb{B}$ & - & - \\
\hline
getBackgroundVolume & - & $\mathbb{R}$ & - \\
\hline
setBackgroundVolume & $\mathbb{R}$ & - & - \\
\hline
getSoundEffectsVolume & - & $\mathbb{R}$ & - \\
\hline
setSoundEffectsVolume & $\mathbb{R}$ & - & - \\
\hline
getTypeOfEvent & - & String & - \\
\hline
setTypeOfEvent & String & - & - \\
\hline
getGrid & - & set of FarmTile & - \\
\hline
setGrid & set of FarmTile & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$\text{turn}:$ \text{$\mathbb{N}$}\\
$\text{money}:$ \text{$\mathbb{R}$}\\
$\text{decisionType}:$ \text{$\mathbb{Z}$}\\
$\text{marketItems}:$ \text{set of Item}\\
$\text{accessToConsultant}:$  \text{$\mathbb{B}$}\\
$\text{isEventHappening}:$  \text{$\mathbb{B}$}\\
$\text{backgroundMusicVolume}:$  \text{$\mathbb{R}$}\\
$\text{soundEffectsVolume}:$  \text{$\mathbb{R}$}\\
$\text{typeOfEvent}:$  \text{String}\\
$\text{grid}:$  \text{set of FarmTile}\\
\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent new GameController(turn, money):
\begin{itemize}
\item transition: $\text{turn, money} := \text{turn, money}$
\item output: $out := \text{self}$
\item exception: None
\end{itemize}

\noindent getTurn():
\begin{itemize}
\item output: $out := \text{turn}$
\item exception: None
\end{itemize}


\noindent setTurn(turn):
\begin{itemize}
\item transition: $\text{turn} := \text{turn}$
\item exception: None
\end{itemize}

\noindent getMoney():
\begin{itemize}
\item output: $out := \text{money}$
\item exception: None
\end{itemize}


\noindent setMoney(money):
\begin{itemize}
\item transition: $\text{money} := \text{money}$
\item exception: None
\end{itemize}

\noindent getSeason():
\begin{itemize}
\item output: $out := \text{SEASONS}[\lfloor(\text{turn} / 4)\rfloor$ \% 4]
\item exception: None
\end{itemize}

\noindent getDecisionType():
\begin{itemize}
\item output: $out := \text{decisionType}$
\item exception: None
\end{itemize}

\noindent getMarketItems():
\begin{itemize}
\item output: $out := \text{marketItems}$
\item exception: None
\end{itemize}

\noindent getAccessToConsultant():
\begin{itemize}
\item output: $out := \text{accessToConsultant}$
\item exception: None
\end{itemize}

\noindent setAccessToConsultant(access):
\begin{itemize}
\item transition: $\text{accessToConsultant} := \text{access}$
\item exception: None
\end{itemize}

\noindent getEventHappening():
\begin{itemize}
\item output: $out := \text{isEventHappening}$
\item exception: None
\end{itemize}

\noindent setEventHappening(isNextEventHappening):
\begin{itemize}
\item output: $\text{isEventHappening} := \text{isNextEventHappening}$
\item exception: None
\end{itemize}

\noindent getBackgroundVolume():
\begin{itemize}
\item output: $out := \text{backgroundMusicVolume}$
\item exception: None
\end{itemize}

\noindent setBackgroundVolume(changedVolume):
\begin{itemize}
\item output: $\text{backgroundMusicVolume} := \text{changedVolume}$
\item exception: None
\end{itemize}

\noindent getSoundEffectsVolume():
\begin{itemize}
\item output: $out := \text{soundEffectsVolume}$
\item exception: None
\end{itemize}

\noindent setSoundEffectsVolume(changedVolume):
\begin{itemize}
\item output: $\text{soundEffectsVolume} := \text{changedVolume}$
\item exception: None
\end{itemize}


\noindent getTypeOfEvent():
\begin{itemize}
\item output: $out := \text{typeOfEvent}$
\item exception: None
\end{itemize}

\noindent setTypeOfEvent(eventType):
\begin{itemize}
\item output: $\text{typeOfEvent} := \text{eventType}$
\item exception: None
\end{itemize}

\noindent getGrid():
\begin{itemize}
\item output: $out := \text{grid}$
\item exception: None
\end{itemize}

\noindent setGrid(updatedGrid):
\begin{itemize}
\item output: $\text{grid} := \text{updatedGrid}$
\item exception: None
\end{itemize}


\medskip

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}
N/A

\end{document}